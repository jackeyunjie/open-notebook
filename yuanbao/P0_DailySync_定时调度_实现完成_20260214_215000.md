# P0 Daily Sync 定时调度实现完成

## 新增文件

```
open_notebook/skills/
├── p0_agents.py          # 4个P0 Agent (Q1P0-Q4P0)
├── p0_orchestrator.py    # Daily Sync 协调器
├── p0_scheduler.py       # 定时调度器 ⬅ 新增
└── __init__.py           # 已更新

api/routers/
└── p0_scheduler.py       # API端点 ⬅ 新增

api/main.py               # 已集成启动/关闭逻辑
```

---

## 核心功能

### 1. P0SyncScheduler - 专用调度器
- 每天自动运行 Daily Sync
- 可配置时间（默认 06:00）
- 支持 cron 表达式（如每6小时）
- 失败重试机制（默认3次）
- 执行历史追踪

### 2. 启动方式

```bash
# 方式1: 环境变量自动启动
P0_DAILY_SYNC_AUTO_START=true
P0_DAILY_SYNC_TIME=06:00
P0_DAILY_SYNC_NOTEBOOK_ID=notebook:xxx

# 方式2: API 启动
POST /api/p0-scheduler/start
{
    "sync_time": "08:00",
    "timezone": "Asia/Shanghai",
    "max_retries": 3
}

# 方式3: Cron 表达式
POST /api/p0-scheduler/start/cron
{
    "cron_expression": "0 */6 * * *"
}
```

### 3. 监控 API

| 端点 | 功能 |
|------|------|
| GET /api/p0-scheduler/status | 查看调度器状态、下次运行时间 |
| POST /api/p0-scheduler/trigger | 立即手动触发同步 |
| GET /api/p0-scheduler/history | 查看执行历史 |
| GET /api/p0-scheduler/health | 健康指标（成功率、平均耗时） |
| PATCH /api/p0-scheduler/schedule?sync_time=08:00 | 动态修改时间 |
| GET /api/p0-scheduler/signals/active | 获取活跃信号 |

---

## 调度器特性

```
Daily Sync Cycle:
┌─────────────┐
│  Scheduled  │──→ 自动每天运行
│  (06:00)    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Retry     │──→ 失败自动重试（3次，间隔30分钟）
│  (if fail)  │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   History   │──→ 记录执行历史（保留100条）
│   Record    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Health    │──→ 健康监控（成功率、平均信号数）
│   Metrics   │
└─────────────┘
```

---

## 使用示例

```python
# 在代码中使用
from open_notebook.skills import p0_sync_scheduler, setup_default_p0_schedule

# 启动定时调度
await setup_default_p0_schedule(runner, sync_time="06:00")

# 手动触发
result = await p0_sync_scheduler.trigger_sync_now()

# 查看状态
status = p0_sync_scheduler.get_status()
print(f"下次运行: {status['next_run_time']}")
print(f"健康状态: {status['health_status']}")  # healthy/warning/critical

# 获取指标
metrics = p0_sync_scheduler.get_health_metrics()
print(f"成功率: {metrics['success_rate_percent']}%")
print(f"平均信号数: {metrics['average_signals_generated']}")
```

---

## 下一步选择

**A.** 添加前端 Dashboard（可视化展示调度器状态和信号）

**B.** 实现 P1 层 Agent（Q1P1-Q4P1 价值判断层）

**C.** 添加通知系统（同步失败时发送通知）

你倾向哪个方向？
