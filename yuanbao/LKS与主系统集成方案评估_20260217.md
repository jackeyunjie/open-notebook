# LKS 与主系统集成方案评估

**评估日期**: 2026-02-17  
**评估目标**: 解决 Living Knowledge System (LKS) 与 Open Notebook 主系统的数据孤岛问题

---

## 当前架构分析

### 数据存储现状

| 系统 | 数据库 | 用途 | 状态 |
|------|--------|------|------|
| **Open Notebook 主系统** | SurrealDB | 文档、图谱、Notebook/Note/Source | ✅ 生产使用 |
| **LKS (P0-P4)** | PostgreSQL + TimescaleDB | 时序数据、Agent 状态、认知演化 | ✅ 已实现 |
| **LangGraph** | SQLite | 对话状态检查点 | ✅ 本地使用 |

### 数据孤岛问题

```
┌─────────────────┐     ┌─────────────────┐
│  Open Notebook  │     │      LKS        │
│   (SurrealDB)   │ ◄──►│ (PostgreSQL)    │
│                 │  ?  │                 │
│ - Notebook      │     │ - Agent 状态    │
│ - Source        │     │ - 时序数据      │
│ - Note          │     │ - 认知演化      │
└─────────────────┘     └─────────────────┘
         │                       │
         ▼                       ▼
   端口 8000                端口 8888
   
   数据不互通，需要显式同步
```

**核心问题**:
1. **双数据库运维**: 需要同时维护 SurrealDB 和 PostgreSQL
2. **数据一致性**: Notebook 删除后，LKS 中的认知数据如何清理？
3. **查询复杂性**: 跨库查询需要手动桥接
4. **部署复杂度**: 需要启动多个数据库服务

---

## 集成方案对比

### 方案 A: 保持现状 + 显式同步层

**描述**: 保留双数据库，添加显式同步机制

```python
# 同步层示例
class LKSSyncManager:
    async def on_notebook_deleted(self, notebook_id: str):
        # 级联删除 LKS 中的相关数据
        await self.lks_db.delete_agent_context(notebook_id)
        await self.lks_db.delete_evolution_history(notebook_id)
```

| 优点 | 缺点 |
|------|------|
| 改动最小 | 数据一致性难以保证 |
| 保留时序数据库优势 | 运维复杂度翻倍 |
| 风险可控 | 需要手动处理所有边界情况 |

**适用场景**: 短期过渡，LKS 作为实验性功能

---

### 方案 B: LKS 迁移到 SurrealDB

**描述**: 将 LKS 的 PostgreSQL 数据迁移到 SurrealDB

```
SurrealDB 扩展:
- 原有: Notebook, Source, Note
- 新增: AgentState, EvolutionHistory, TimeSeriesData
```

| 优点 | 缺点 |
|------|------|
| 单一数据库，运维简单 | SurrealDB 时序功能不如 TimescaleDB |
| 天然支持图谱关系 | 需要重写 LKS 数据层 |
| 事务一致性 | 迁移风险 |

**技术可行性**: ⭐⭐⭐ 中等
- SurrealDB 支持时间戳和范围查询
- 需要评估时序数据性能

---

### 方案 C: 主系统迁移到 PostgreSQL

**描述**: 将 Open Notebook 主系统从 SurrealDB 迁移到 PostgreSQL

| 优点 | 缺点 |
|------|------|
| PostgreSQL 成熟稳定 | 迁移工作量大 |
| 丰富的生态工具 | SurrealDB 的图谱功能需用 pg_graph 替代 |
| 单一技术栈 | 需要重写数据层 |

**技术可行性**: ⭐⭐ 较低
- 需要替换 SurrealDB 特有的图谱查询
- 数据模型需要重新设计

---

### 方案 D: 混合架构 + API 网关

**描述**: 保留双数据库，通过 API 网关统一访问

```
┌─────────────────────────────────────────┐
│           API Gateway Layer             │
│  ┌─────────────┐    ┌─────────────┐    │
│  │  Notebook   │    │    LKS      │    │
│  │    API      │◄──►│    API      │    │
│  └──────┬──────┘    └──────┬──────┘    │
│         │                  │            │
│         ▼                  ▼            │
│  ┌─────────────┐    ┌─────────────┐    │
│  │  SurrealDB  │    │ PostgreSQL  │    │
│  └─────────────┘    └─────────────┘    │
└─────────────────────────────────────────┘
```

| 优点 | 缺点 |
|------|------|
| 各数据库发挥优势 | 架构复杂度增加 |
| 渐进式演进 | 需要维护 API 网关 |
| 风险分散 | 跨库事务困难 |

**推荐度**: ⭐⭐⭐⭐ 较高

---

## 推荐方案: 方案 D (API 网关 + 渐进式演进)

### 实施路径

#### 阶段 1: 统一 API 层 (1-2 周)

1. **创建统一的数据访问接口**
```python
# open_notebook/data_gateway/__init__.py
class DataGateway:
    """统一数据访问网关"""
    
    async def get_notebook_with_context(self, notebook_id: str) -> NotebookContext:
        """获取 Notebook 及其 LKS 上下文"""
        notebook = await self.surreal_db.get_notebook(notebook_id)
        lks_context = await self.lks_db.get_context(notebook_id)
        return NotebookContext(notebook=notebook, lks_context=lks_context)
```

2. **添加数据同步钩子**
```python
# 在 Notebook 删除时级联清理 LKS 数据
class NotebookService:
    async def delete_notebook(self, notebook_id: str):
        await self.surreal_db.delete(notebook_id)
        await self.lks_db.cleanup_notebook_data(notebook_id)  # 级联清理
```

#### 阶段 2: 数据一致性保障 (2-3 周)

1. **事件驱动同步**
```python
# 使用消息队列或事件总线
class DataSyncEventBus:
    async def publish(self, event: DataEvent):
        if event.type == "notebook.deleted":
            await self.lks_sync_handler.handle_delete(event.notebook_id)
```

2. **定期一致性检查**
```python
# 定时任务检查数据一致性
class ConsistencyChecker:
    async def check_orphan_lks_data(self):
        # 找出 LKS 中存在但主系统中已删除的数据
        pass
```

#### 阶段 3: 可选的数据库合并评估 (长期)

根据使用情况和性能数据，评估是否需要合并到单一数据库。

---

## 关键决策点

### 决策 1: 是否立即实施集成？

| 选项 | 建议 | 理由 |
|------|------|------|
| **立即实施** | ⭐⭐⭐ | 如果 LKS 要成为核心功能 |
| **保持现状** | ⭐⭐ | 如果 LKS 仍是实验性 |
| **冻结 LKS** | ⭐ | 如果资源有限 |

### 决策 2: 长期数据库策略

| 选项 | 适用场景 |
|------|----------|
| **保持双库** | 需要时序数据库高级功能 |
| **合并到 SurrealDB** | 简化运维优先 |
| **合并到 PostgreSQL** | 团队更熟悉 PostgreSQL |

---

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 数据不一致 | 高 | 事件驱动同步 + 定期检查 |
| 性能下降 | 中 | 缓存层 + 异步处理 |
| 开发复杂度 | 中 | 清晰的抽象层 + 文档 |
| 运维负担 | 高 | 自动化监控 + 告警 |

---

## 下一步行动

1. **立即**: 在 Notebook 删除时添加 LKS 数据清理钩子
2. **本周**: 设计统一数据访问接口
3. **下周**: 实现基础的数据网关层
4. **本月**: 添加数据一致性检查和监控

---

## 结论

**推荐方案 D (API 网关 + 渐进式演进)**，理由：
1. 风险可控，可以渐进式实施
2. 保留各数据库的技术优势
3. 为未来的架构决策保留灵活性
4. 不需要大规模重写代码

**关键成功因素**:
- 清晰的数据访问抽象层
- 完善的数据一致性机制
- 充分的监控和告警

---

*评估完成时间: 2026-02-17*  
*建议复审时间: 实施阶段 1 完成后*
