"""P2 Layer Agents - Relationship Layer for Organic Growth System.

This module provides the P2 (Relationship Layer) agents that build trust,
forge community connections, and amplify content reach.

Architecture:
    P0 Layer (Perception) â†’ P1 Layer (Value Judgment) â†’ P2 Layer (Relationship) â†’ P3 Layer (Evolution)

Four Quadrant Agents at P2:
    - Q1P2 TrustBuilder: Establishes trust through solution delivery
    - Q2P2 CommunityBinder: Strengthens emotional community bonds
    - Q3P2 ViralEngine: Optimizes content for viral spread
    - Q4P2 InfluenceNetwork: Expands influence through key connections

Relationship Building Framework:
    Each P2 agent receives prioritized signals from P1 and executes
    relationship-building actions to move users deeper into the funnel.
"""

import asyncio
import json
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Set

from loguru import logger

from open_notebook.domain.notebook import Note
from open_notebook.skills.base import Skill, SkillConfig, SkillContext, SkillResult, SkillStatus
from open_notebook.skills.p0_orchestrator import SharedMemory
from open_notebook.skills.p1_agents import ValueAssessment, ValuePriority
from open_notebook.skills.feedback_loop import FeedbackCollector, FeedbackLoopOrchestrator
from open_notebook.skills.registry import register_skill


class RelationshipAction(Enum):
    """Types of relationship-building actions."""
    BUILD_TRUST = "build_trust"
    ENGAGE_COMMUNITY = "engage_community"
    AMPLIFY_CONTENT = "amplify_content"
    EXPAND_NETWORK = "expand_network"
    NURTURE_LEAD = "nurture_lead"


class TrustLevel(Enum):
    """Stages of trust development."""
    AWARENESS = "awareness"      # Just discovered
    INTEREST = "interest"        # Showing interest
    EVALUATION = "evaluation"    # Considering solution
    TRUST = "trust"              # Trust established
    LOYALTY = "loyalty"          # Repeat engagement
    ADVOCACY = "advocacy"        # Active promoter


@dataclass
class RelationshipPlan:
    """A plan for building relationship with a specific user segment."""
    plan_id: str
    target_segment: str
    current_trust_level: TrustLevel
    target_trust_level: TrustLevel
    actions: List[Dict[str, Any]]
    timeline_days: int
    success_metrics: Dict[str, Any]
    created_at: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "plan_id": self.plan_id,
            "target_segment": self.target_segment,
            "current_trust_level": self.current_trust_level.value,
            "target_trust_level": self.target_trust_level.value,
            "actions": self.actions,
            "timeline_days": self.timeline_days,
            "success_metrics": self.success_metrics,
            "created_at": self.created_at.isoformat()
        }


@dataclass
class RelationshipReport:
    """Report generated by P2 agent after relationship building."""
    agent_name: str
    quadrant: str
    layer: str = "P2"
    generated_at: datetime = field(default_factory=datetime.utcnow)
    plans_created: List[RelationshipPlan] = field(default_factory=list)
    actions_executed: List[Dict[str, Any]] = field(default_factory=list)
    trust_metrics: Dict[str, Any] = field(default_factory=dict)
    insights: List[str] = field(default_factory=list)
    recommendations_for_p3: List[Dict[str, Any]] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "agent_name": self.agent_name,
            "quadrant": self.quadrant,
            "layer": self.layer,
            "generated_at": self.generated_at.isoformat(),
            "plans_count": len(self.plans_created),
            "plans": [p.to_dict() for p in self.plans_created],
            "actions_executed": self.actions_executed,
            "trust_metrics": self.trust_metrics,
            "insights": self.insights,
            "recommendations_for_p3": self.recommendations_for_p3
        }


# =============================================================================
# Q1P2: Trust Builder Agent
# =============================================================================

@register_skill
class TrustBuilderAgent(Skill):
    """Q1P2 Agent: Establishes trust through solution delivery and reliability.

    This agent receives high-value painpoint assessments from Q1P1 and designs
    trust-building sequences that move users from awareness to trust through
    demonstrated expertise and solution delivery.

    Trust Building Framework:
        1. Quick Win Content (immediate value delivery)
        2. Proof Content (case studies, testimonials)
        3. Education Content (deep expertise demonstration)
        4. Offer Content (solution presentation)

    Trust Level Progression:
        Awareness â†’ Interest â†’ Evaluation â†’ Trust â†’ Loyalty
    """

    skill_type = "trust_builder_agent"
    name = "Trust Builder Agent (Q1P2)"
    description = "P2 relationship agent for building trust through solutions"

    parameters_schema = {
        "signal_sources": {
            "type": "array",
            "items": {"type": "string"},
            "default": ["shared_memory"],
            "description": "Where to get Q1P1 assessments from"
        },
        "min_priority": {
            "type": "string",
            "default": "high",
            "enum": ["critical", "high", "medium"],
            "description": "Minimum priority level to act on"
        },
        "trust_sequence_length": {
            "type": "integer",
            "default": 4,
            "minimum": 3,
            "maximum": 7,
            "description": "Number of touchpoints in trust sequence"
        },
        "hours_lookback": {
            "type": "integer",
            "default": 48,
            "minimum": 1,
            "maximum": 168
        },
        "target_notebook_id": {
            "type": "string",
            "default": ""
        }
    }

    def __init__(self, config: SkillConfig):
        self.signal_sources = config.parameters.get("signal_sources", ["shared_memory"])
        self.min_priority = config.parameters.get("min_priority", "high")
        self.trust_sequence_length = config.parameters.get("trust_sequence_length", 4)
        self.hours_lookback = config.parameters.get("hours_lookback", 48)
        self.target_notebook_id = config.parameters.get("target_notebook_id", "")
        self.shared_memory = SharedMemory()
        self.plans: List[RelationshipPlan] = []
        self.feedback_orchestrator = FeedbackLoopOrchestrator()
        super().__init__(config)

    async def _fetch_q1p1_assessments(self) -> List[Dict[str, Any]]:
        """Fetch value assessments from Q1P1 layer."""
        assessments = []

        for source in self.signal_sources:
            if source == "shared_memory":
                # Get P1 assessments for Q1
                recent = self.shared_memory.get_recent_signals(hours=self.hours_lookback)
                q1_assessments = [
                    s for s in recent
                    if s.get("source_quadrant") == "Q1" or
                    "Q1" in str(s.get("target_quadrants", []))
                ]
                assessments.extend(q1_assessments)

        # Filter by minimum priority
        priority_order = {"critical": 4, "high": 3, "medium": 2, "low": 1}
        min_level = priority_order.get(self.min_priority, 3)

        filtered = [
            a for a in assessments
            if priority_order.get(a.get("priority", ""), 0) >= min_level
        ]

        logger.info(f"Fetched {len(filtered)} Q1P1 assessments (min: {self.min_priority})")
        return filtered

    def _design_trust_sequence(self, assessment: Dict[str, Any]) -> RelationshipPlan:
        """Design a trust-building sequence for a painpoint."""
        signal_id = assessment.get("signal_id", "unknown")
        priority = assessment.get("priority", "medium")

        # Determine starting trust level based on painpoint type
        pain_type = assessment.get("pain_type", "")
        if pain_type == "instant":
            current_level = TrustLevel.AWARENESS
            target_level = TrustLevel.TRUST
        elif pain_type == "continuous":
            current_level = TrustLevel.INTEREST
            target_level = TrustLevel.LOYALTY
        else:  # hidden
            current_level = TrustLevel.EVALUATION
            target_level = TrustLevel.TRUST

        # Build sequence based on priority
        actions = []

        # Touch 1: Quick Win (immediate value)
        actions.append({
            "step": 1,
            "type": "quick_win",
            "content_type": "short_video" if priority in ["critical", "high"] else "post",
            "goal": "Deliver immediate value, establish credibility",
            "timing": "immediate",
            "success_metric": "views > 1000, saves > 100"
        })

        # Touch 2: Proof
        actions.append({
            "step": 2,
            "type": "proof",
            "content_type": "case_study",
            "goal": "Show real results, build social proof",
            "timing": "day_1",
            "success_metric": "engagement_rate > 5%"
        })

        # Touch 3: Deep Education
        actions.append({
            "step": 3,
            "type": "education",
            "content_type": "detailed_guide",
            "goal": "Demonstrate expertise, address objections",
            "timing": "day_3",
            "success_metric": "completion_rate > 30%"
        })

        # Touch 4: Soft Offer (if high priority)
        if priority in ["critical", "high"]:
            actions.append({
                "step": 4,
                "type": "soft_offer",
                "content_type": "webinar_or_lead_magnet",
                "goal": "Capture leads, move to evaluation",
                "timing": "day_7",
                "success_metric": "conversion_rate > 10%"
            })

        return RelationshipPlan(
            plan_id=f"trust_{signal_id}",
            target_segment=f"users_with_{pain_type}_pain",
            current_trust_level=current_level,
            target_trust_level=target_level,
            actions=actions,
            timeline_days=14 if priority == "critical" else 21,
            success_metrics={
                "trust_score_increase": "+30 points",
                "lead_conversion": "10-15%",
                "content_engagement": ">5% average"
            }
        )

    async def execute(self, context: SkillContext) -> SkillResult:
        """Execute Q1P2 trust building."""
        started_at = datetime.utcnow()

        try:
            assessments = await self._fetch_q1p1_assessments()
            if not assessments:
                return SkillResult(
                    skill_id=context.skill_id,
                    status=SkillStatus.SUCCESS,
                    started_at=started_at,
                    output={"message": "No Q1P1 assessments to process", "plans": []}
                )

            # Design trust sequences for each assessment
            self.plans = []
            for assessment in assessments[:10]:  # Top 10
                plan = self._design_trust_sequence(assessment)
                self.plans.append(plan)

            # Generate report
            report = RelationshipReport(agent_name="TrustBuilderAgent", quadrant="Q1")
            report.plans_created = self.plans

            # Calculate trust metrics
            total_touchpoints = sum(len(p.actions) for p in self.plans)
            report.trust_metrics = {
                "plans_created": len(self.plans),
                "total_touchpoints": total_touchpoints,
                "avg_sequence_length": total_touchpoints / len(self.plans) if self.plans else 0,
                "estimated_timeline_days": max(p.timeline_days for p in self.plans) if self.plans else 0
            }

            # Generate insights
            critical_plans = sum(1 for p in self.plans if p.target_trust_level == TrustLevel.TRUST)
            if critical_plans > 0:
                report.insights.append(
                    f"{critical_plans} critical trust-building sequences prioritized for immediate execution"
                )

            # Recommendations for P3
            for plan in self.plans[:3]:
                report.recommendations_for_p3.append({
                    "plan_id": plan.plan_id,
                    "action": "optimize_conversion",
                    "expected_outcome": f"Move users from {plan.current_trust_level.value} to {plan.target_trust_level.value}",
                    "measurement": "trust_score + conversion_rate"
                })

            # Store plans to SharedMemory
            for plan in self.plans:
                key = f"p2_plan:q1:{plan.plan_id}"
                self.shared_memory.store(key, plan.to_dict(), ttl_seconds=604800)  # 7 days

            output = {
                "plans_created": len(self.plans),
                "trust_metrics": report.trust_metrics,
                "top_plans": [p.to_dict() for p in self.plans[:5]],
                "report": report.to_dict()
            }

            # Collect feedback for learning loop
            if self.plans:
                for plan in self.plans[:3]:  # Collect feedback for top 3 plans
                    # Simulate expected metrics (in production: actual execution results)
                    expected_metrics = {
                        "engagement_rate": 0.06 + (plan.target_trust_level.value == "trust" and 0.03 or 0),
                        "conversion_rate": 0.08 if plan.target_trust_level == TrustLevel.TRUST else 0.05,
                        "trust_progression": f"{plan.current_trust_level.value}_to_{plan.target_trust_level.value}"
                    }
                    self.feedback_orchestrator.collect_and_learn(
                        plan_id=plan.plan_id,
                        quadrant="Q1",
                        metrics=expected_metrics,
                        outcome_value=150 if plan.target_trust_level == TrustLevel.TRUST else 80
                    )

            created_note_ids = []
            if self.target_notebook_id:
                note = Note(
                    title=f"[Q1P2] Trust Building Plans - {datetime.now().strftime('%Y-%m-%d')}",
                    content=self._format_report(report),
                    note_type="ai"
                )
                await note.save()
                await note.add_to_notebook(self.target_notebook_id)
                created_note_ids.append(str(note.id))

            return SkillResult(
                skill_id=context.skill_id,
                status=SkillStatus.SUCCESS,
                started_at=started_at,
                completed_at=datetime.utcnow(),
                output=output,
                created_note_ids=created_note_ids
            )

        except Exception as e:
            logger.exception(f"Q1P2 execution failed: {e}")
            return SkillResult(skill_id=context.skill_id, status=SkillStatus.FAILED,
                             started_at=started_at, error_message=str(e))

    def _format_report(self, report: RelationshipReport) -> str:
        lines = [
            "# ğŸ¤ Q1P2 Trust Builder Report\n",
            f"**Plans Created:** {len(report.plans_created)}\n",
            "## Trust Building Sequences\n"
        ]

        for i, plan in enumerate(report.plans_created[:10], 1):
            lines.extend([
                f"### Plan #{i}: {plan.plan_id}",
                f"**Target:** {plan.target_segment}",
                f"**Progression:** {plan.current_trust_level.value} â†’ {plan.target_trust_level.value}",
                f"**Timeline:** {plan.timeline_days} days",
                "**Sequence:**"
            ])
            for action in plan.actions:
                lines.append(f"  {action['step']}. {action['type']} ({action['timing']}) - {action['goal']}")
            lines.append("")

        if report.insights:
            lines.extend(["\n## Insights\n"] + [f"- {i}" for i in report.insights])

        return "\n".join(lines)


# =============================================================================
# Q2P2: Community Binder Agent
# =============================================================================

@register_skill
class CommunityBinderAgent(Skill):
    """Q2P2 Agent: Strengthens emotional community bonds and belonging.

    This agent receives validated emotional signals from Q2P1 and designs
    community engagement strategies that create belonging and mutual support.

    Community Building Framework:
        1. Shared Experience Content ("you're not alone")
        2. Discussion Facilitation (community conversations)
        3. Recognition Programs (celebrating members)
        4. Peer Support Structures (member-to-member help)
    """

    skill_type = "community_binder_agent"
    name = "Community Binder Agent (Q2P2)"
    description = "P2 relationship agent for strengthening community bonds"

    parameters_schema = {
        "signal_sources": {"type": "array", "items": {"type": "string"}, "default": ["shared_memory"]},
        "min_resonance_score": {"type": "integer", "default": 70},
        "hours_lookback": {"type": "integer", "default": 48},
        "target_notebook_id": {"type": "string", "default": ""}
    }

    def __init__(self, config: SkillConfig):
        self.signal_sources = config.parameters.get("signal_sources", ["shared_memory"])
        self.min_resonance_score = config.parameters.get("min_resonance_score", 70)
        self.hours_lookback = config.parameters.get("hours_lookback", 48)
        self.target_notebook_id = config.parameters.get("target_notebook_id", "")
        self.shared_memory = SharedMemory()
        self.plans: List[RelationshipPlan] = []
        self.feedback_orchestrator = FeedbackLoopOrchestrator()
        super().__init__(config)

    async def _fetch_q2p1_assessments(self) -> List[Dict[str, Any]]:
        """Fetch emotional assessments from Q2P1."""
        assessments = []
        for source in self.signal_sources:
            if source == "shared_memory":
                recent = self.shared_memory.get_recent_signals(hours=self.hours_lookback)
                q2_assessments = [
                    s for s in recent
                    if s.get("source_quadrant") == "Q2"
                ]
                assessments.extend(q2_assessments)
        return [a for a in assessments if a.get("overall_score", 0) >= self.min_resonance_score]

    def _design_community_strategy(self, assessment: Dict[str, Any]) -> RelationshipPlan:
        """Design a community engagement strategy."""
        signal_id = assessment.get("signal_id", "unknown")
        emotion_type = assessment.get("emotion_type", "general")

        actions = [
            {
                "step": 1,
                "type": "shared_experience",
                "content": f"Create 'You're not alone' content about {emotion_type}",
                "goal": "Create belonging through shared emotion"
            },
            {
                "step": 2,
                "type": "discussion_prompt",
                "content": f"Ask community about their {emotion_type} experiences",
                "goal": "Facilitate peer connection"
            },
            {
                "step": 3,
                "type": "member_spotlight",
                "content": "Feature community member story",
                "goal": "Recognize and celebrate members"
            }
        ]

        return RelationshipPlan(
            plan_id=f"community_{signal_id}",
            target_segment=f"users_experiencing_{emotion_type}",
            current_trust_level=TrustLevel.INTEREST,
            target_trust_level=TrustLevel.LOYALTY,
            actions=actions,
            timeline_days=21,
            success_metrics={"engagement_rate": ">8%", "member_retention": "+20%"}
        )

    async def execute(self, context: SkillContext) -> SkillResult:
        """Execute Q2P2 community binding."""
        started_at = datetime.utcnow()

        try:
            assessments = await self._fetch_q2p1_assessments()
            if not assessments:
                return SkillResult(
                    skill_id=context.skill_id,
                    status=SkillStatus.SUCCESS,
                    started_at=started_at,
                    output={"message": "No Q2P1 assessments to process", "plans": []}
                )

            self.plans = []
            for assessment in assessments[:8]:
                plan = self._design_community_strategy(assessment)
                self.plans.append(plan)

            report = RelationshipReport(agent_name="CommunityBinderAgent", quadrant="Q2")
            report.plans_created = self.plans
            report.trust_metrics = {
                "community_plans": len(self.plans),
                "avg_engagement_target": "8-12%"
            }

            for plan in self.plans:
                key = f"p2_plan:q2:{plan.plan_id}"
                self.shared_memory.store(key, plan.to_dict(), ttl_seconds=604800)

            output = {
                "community_plans": len(self.plans),
                "top_plans": [p.to_dict() for p in self.plans[:5]],
                "report": report.to_dict()
            }

            # Collect feedback for learning loop
            if self.plans:
                for plan in self.plans[:3]:
                    expected_metrics = {
                        "engagement_rate": 0.09,
                        "comment_sentiment": "positive",
                        "member_retention": 0.85
                    }
                    self.feedback_orchestrator.collect_and_learn(
                        plan_id=plan.plan_id,
                        quadrant="Q2",
                        metrics=expected_metrics,
                        qualitative_data=["Community resonance strong"],
                        outcome_value=120
                    )

            created_note_ids = []
            if self.target_notebook_id:
                note = Note(
                    title=f"[Q2P2] Community Plans - {datetime.now().strftime('%Y-%m-%d')}",
                    content=self._format_report(report),
                    note_type="ai"
                )
                await note.save()
                await note.add_to_notebook(self.target_notebook_id)
                created_note_ids.append(str(note.id))

            return SkillResult(
                skill_id=context.skill_id,
                status=SkillStatus.SUCCESS,
                started_at=started_at,
                completed_at=datetime.utcnow(),
                output=output,
                created_note_ids=created_note_ids
            )

        except Exception as e:
            logger.exception(f"Q2P2 execution failed: {e}")
            return SkillResult(skill_id=context.skill_id, status=SkillStatus.FAILED,
                             started_at=started_at, error_message=str(e))

    def _format_report(self, report: RelationshipReport) -> str:
        lines = ["# ğŸ’ Q2P2 Community Binder Report\n", f"**Community Plans:** {len(report.plans_created)}\n"]
        for plan in report.plans_created[:5]:
            lines.extend([f"### {plan.plan_id}", f"**Target:** {plan.target_segment}",
                         "**Actions:**"] + [f"  - {a['type']}: {a['goal']}" for a in plan.actions] + [""])
        return "\n".join(lines)


# =============================================================================
# Q3P2: Viral Engine Agent
# =============================================================================

@register_skill
class ViralEngineAgent(Skill):
    """Q3P2 Agent: Optimizes content for viral spread and amplification.

    This agent receives high-value trend assessments from Q3P1 and designs
    content optimization strategies to maximize reach and viral potential.

    Viral Optimization Framework:
        1. Hook Optimization (pattern interrupts, curiosity gaps)
        2. Shareability Engineering (social currency, practical value)
        3. Distribution Timing (optimal posting windows)
        4. Cross-Platform Adaptation (format optimization)
    """

    skill_type = "viral_engine_agent"
    name = "Viral Engine Agent (Q3P2)"
    description = "P2 relationship agent for viral content optimization"

    parameters_schema = {
        "signal_sources": {"type": "array", "items": {"type": "string"}, "default": ["shared_memory"]},
        "min_trend_score": {"type": "integer", "default": 75},
        "hours_lookback": {"type": "integer", "default": 48},
        "target_notebook_id": {"type": "string", "default": ""}
    }

    def __init__(self, config: SkillConfig):
        self.signal_sources = config.parameters.get("signal_sources", ["shared_memory"])
        self.min_trend_score = config.parameters.get("min_trend_score", 75)
        self.hours_lookback = config.parameters.get("hours_lookback", 48)
        self.target_notebook_id = config.parameters.get("target_notebook_id", "")
        self.shared_memory = SharedMemory()
        self.plans: List[RelationshipPlan] = []
        self.feedback_orchestrator = FeedbackLoopOrchestrator()
        super().__init__(config)

    async def _fetch_q3p1_assessments(self) -> List[Dict[str, Any]]:
        """Fetch trend assessments from Q3P1."""
        assessments = []
        for source in self.signal_sources:
            if source == "shared_memory":
                recent = self.shared_memory.get_recent_signals(hours=self.hours_lookback)
                q3_assessments = [s for s in recent if s.get("source_quadrant") == "Q3"]
                assessments.extend(q3_assessments)
        return [a for a in assessments if a.get("overall_score", 0) >= self.min_trend_score]

    def _design_viral_strategy(self, assessment: Dict[str, Any]) -> RelationshipPlan:
        """Design a viral optimization strategy."""
        signal_id = assessment.get("signal_id", "unknown")
        topic = assessment.get("topic", "trend")

        actions = [
            {
                "step": 1,
                "type": "hook_design",
                "content": f"Create pattern interrupt hook for {topic}",
                "goal": "Stop scroll, create curiosity gap"
            },
            {
                "step": 2,
                "type": "shareability_boost",
                "content": "Add practical value and social currency elements",
                "goal": "Increase save and share rates"
            },
            {
                "step": 3,
                "type": "optimal_timing",
                "content": "Schedule for peak audience hours",
                "goal": "Maximize initial engagement velocity"
            },
            {
                "step": 4,
                "type": "cross_platform",
                "content": "Adapt format for each platform",
                "goal": "Extend reach across channels"
            }
        ]

        return RelationshipPlan(
            plan_id=f"viral_{signal_id}",
            target_segment=f"trend_followers_{topic}",
            current_trust_level=TrustLevel.AWARENESS,
            target_trust_level=TrustLevel.INTEREST,
            actions=actions,
            timeline_days=7,
            success_metrics={"reach": ">50K", "shares": ">1000", "saves": ">500"}
        )

    async def execute(self, context: SkillContext) -> SkillResult:
        """Execute Q3P2 viral optimization."""
        started_at = datetime.utcnow()

        try:
            assessments = await self._fetch_q3p1_assessments()
            if not assessments:
                return SkillResult(
                    skill_id=context.skill_id,
                    status=SkillStatus.SUCCESS,
                    started_at=started_at,
                    output={"message": "No Q3P1 assessments to process", "plans": []}
                )

            self.plans = []
            for assessment in assessments[:5]:  # Top 5 trends
                plan = self._design_viral_strategy(assessment)
                self.plans.append(plan)

            report = RelationshipReport(agent_name="ViralEngineAgent", quadrant="Q3")
            report.plans_created = self.plans
            report.trust_metrics = {"viral_plans": len(self.plans), "estimated_reach": "250K+"}

            for plan in self.plans:
                key = f"p2_plan:q3:{plan.plan_id}"
                self.shared_memory.store(key, plan.to_dict(), ttl_seconds=604800)

            output = {
                "viral_plans": len(self.plans),
                "top_strategies": [p.to_dict() for p in self.plans[:5]],
                "report": report.to_dict()
            }

            created_note_ids = []
            if self.target_notebook_id:
                note = Note(
                    title=f"[Q3P2] Viral Strategies - {datetime.now().strftime('%Y-%m-%d')}",
                    content=self._format_report(report),
                    note_type="ai"
                )
                await note.save()
                await note.add_to_notebook(self.target_notebook_id)
                created_note_ids.append(str(note.id))

            # Collect feedback for learning loop
            if self.plans:
                for plan in self.plans[:3]:
                    expected_metrics = {
                        "reach": 50000,
                        "shares": 1000,
                        "engagement_rate": 0.08
                    }
                    self.feedback_orchestrator.collect_and_learn(
                        plan_id=plan.plan_id,
                        quadrant="Q3",
                        metrics=expected_metrics,
                        outcome_value=200
                    )

            return SkillResult(
                skill_id=context.skill_id,
                status=SkillStatus.SUCCESS,
                started_at=started_at,
                completed_at=datetime.utcnow(),
                output=output,
                created_note_ids=created_note_ids
            )

        except Exception as e:
            logger.exception(f"Q3P2 execution failed: {e}")
            return SkillResult(skill_id=context.skill_id, status=SkillStatus.FAILED,
                             started_at=started_at, error_message=str(e))

    def _format_report(self, report: RelationshipReport) -> str:
        lines = ["# ğŸš€ Q3P2 Viral Engine Report\n", f"**Viral Plans:** {len(report.plans_created)}\n"]
        for plan in report.plans_created[:5]:
            lines.extend([f"### {plan.plan_id}", f"**Target:** {plan.target_segment}",
                         "**Optimization:**"] + [f"  - {a['type']}: {a['goal']}" for a in plan.actions] + [""])
        return "\n".join(lines)


# =============================================================================
# Q4P2: Influence Network Agent
# =============================================================================

@register_skill
class InfluenceNetworkAgent(Skill):
    """Q4P2 Agent: Expands influence through key connections and partnerships.

    This agent receives high-potential scenario assessments from Q4P1 and designs
    influence expansion strategies to reach new audiences through networks.

    Influence Expansion Framework:
        1. Key Person Identification (influencers, connectors)
        2. Collaboration Opportunities (guest appearances, co-creation)
        3. Partnership Development (strategic alliances)
        4. Referral Program Design (incentivized sharing)
    """

    skill_type = "influence_network_agent"
    name = "Influence Network Agent (Q4P2)"
    description = "P2 relationship agent for expanding influence networks"

    parameters_schema = {
        "signal_sources": {"type": "array", "items": {"type": "string"}, "default": ["shared_memory"]},
        "min_conversion_score": {"type": "integer", "default": 70},
        "hours_lookback": {"type": "integer", "default": 48},
        "target_notebook_id": {"type": "string", "default": ""}
    }

    def __init__(self, config: SkillConfig):
        self.signal_sources = config.parameters.get("signal_sources", ["shared_memory"])
        self.min_conversion_score = config.parameters.get("min_conversion_score", 70)
        self.hours_lookback = config.parameters.get("hours_lookback", 48)
        self.target_notebook_id = config.parameters.get("target_notebook_id", "")
        self.shared_memory = SharedMemory()
        self.plans: List[RelationshipPlan] = []
        self.feedback_orchestrator = FeedbackLoopOrchestrator()
        super().__init__(config)

    async def _fetch_q4p1_assessments(self) -> List[Dict[str, Any]]:
        """Fetch demand assessments from Q4P1."""
        assessments = []
        for source in self.signal_sources:
            if source == "shared_memory":
                recent = self.shared_memory.get_recent_signals(hours=self.hours_lookback)
                q4_assessments = [s for s in recent if s.get("source_quadrant") == "Q4"]
                assessments.extend(q4_assessments)
        return [a for a in assessments if a.get("overall_score", 0) >= self.min_conversion_score]

    def _design_influence_strategy(self, assessment: Dict[str, Any]) -> RelationshipPlan:
        """Design an influence expansion strategy."""
        signal_id = assessment.get("signal_id", "unknown")
        scenario = assessment.get("scenario", "market")

        actions = [
            {
                "step": 1,
                "type": "key_person_identification",
                "content": f"Identify influencers in {scenario} space",
                "goal": "Map key players and connectors"
            },
            {
                "step": 2,
                "type": "collaboration_outreach",
                "content": "Propose value-aligned collaborations",
                "goal": "Establish partnerships"
            },
            {
                "step": 3,
                "type": "referral_program",
                "content": "Design incentivized sharing mechanism",
                "goal": "Activate network effects"
            }
        ]

        return RelationshipPlan(
            plan_id=f"influence_{signal_id}",
            target_segment=f"new_market_{scenario}",
            current_trust_level=TrustLevel.AWARENESS,
            target_trust_level=TrustLevel.EVALUATION,
            actions=actions,
            timeline_days=30,
            success_metrics={"partnerships": 3, "reach_expansion": "+50%", "referrals": 100}
        )

    async def execute(self, context: SkillContext) -> SkillResult:
        """Execute Q4P2 influence expansion."""
        started_at = datetime.utcnow()

        try:
            assessments = await self._fetch_q4p1_assessments()
            if not assessments:
                return SkillResult(
                    skill_id=context.skill_id,
                    status=SkillStatus.SUCCESS,
                    started_at=started_at,
                    output={"message": "No Q4P1 assessments to process", "plans": []}
                )

            self.plans = []
            for assessment in assessments[:5]:
                plan = self._design_influence_strategy(assessment)
                self.plans.append(plan)

            report = RelationshipReport(agent_name="InfluenceNetworkAgent", quadrant="Q4")
            report.plans_created = self.plans
            report.trust_metrics = {"influence_plans": len(self.plans), "partnership_targets": len(self.plans) * 3}

            for plan in self.plans:
                key = f"p2_plan:q4:{plan.plan_id}"
                self.shared_memory.store(key, plan.to_dict(), ttl_seconds=604800)

            output = {
                "influence_plans": len(self.plans),
                "top_strategies": [p.to_dict() for p in self.plans[:5]],
                "report": report.to_dict()
            }

            created_note_ids = []
            if self.target_notebook_id:
                note = Note(
                    title=f"[Q4P2] Influence Network - {datetime.now().strftime('%Y-%m-%d')}",
                    content=self._format_report(report),
                    note_type="ai"
                )
                await note.save()
                await note.add_to_notebook(self.target_notebook_id)
                created_note_ids.append(str(note.id))

            # Collect feedback for learning loop
            if self.plans:
                for plan in self.plans[:3]:
                    expected_metrics = {
                        "partnerships_formed": 2,
                        "referrals_generated": 50,
                        "reach_expansion": 0.3
                    }
                    self.feedback_orchestrator.collect_and_learn(
                        plan_id=plan.plan_id,
                        quadrant="Q4",
                        metrics=expected_metrics,
                        outcome_value=300
                    )

            return SkillResult(
                skill_id=context.skill_id,
                status=SkillStatus.SUCCESS,
                started_at=started_at,
                completed_at=datetime.utcnow(),
                output=output,
                created_note_ids=created_note_ids
            )

        except Exception as e:
            logger.exception(f"Q4P2 execution failed: {e}")
            return SkillResult(skill_id=context.skill_id, status=SkillStatus.FAILED,
                             started_at=started_at, error_message=str(e))

    def _format_report(self, report: RelationshipReport) -> str:
        lines = ["# ğŸŒ Q4P2 Influence Network Report\n", f"**Influence Plans:** {len(report.plans_created)}\n"]
        for plan in report.plans_created[:5]:
            lines.extend([f"### {plan.plan_id}", f"**Target Market:** {plan.target_segment}",
                         "**Strategy:**"] + [f"  - {a['type']}: {a['goal']}" for a in plan.actions] + [""])
        return "\n".join(lines)
